[run.sh] Log file: /dev/ssd1/gjw/prvr/semantic-transformer-v2/boundary_detection/logs/run_20260126_171022.log
[run.sh] Merged train/val JSONL: ./output/activitynet_trainval_merged.jsonl
[run.sh] Inference JSONLs: /dev/hdd2/gjw/datasets/activitynet/activitynet_train.jsonl,/dev/hdd2/gjw/datasets/activitynet/activitynet_val.jsonl
[run.sh] Inference outputs: ./output/boundaries_act_train.json,./output/boundaries_act_val.json
[run.sh] Coarse mode: peaks (sim_threshold=0.65)
[run.sh] Fine params: seq_len=2 feature_dim=512 batch_size=128 lr=1e-4 epochs=20 layers=2 heads=8 ff_dim=1024 use_local_max=0 alpha=3 threshold_std=1.0 segment_pooling=self_attn
[run.sh] Level params: seq_len=3 batch_size=128 lr=1e-4 epochs=20 layers=2 heads=8 ff_dim=1024 use_local_max=0 alpha=2 threshold_std=0 threshold_mode=mad ckpt_dir=./checkpoints/level
[run.sh] Recursive params: levels=5 until_one=1 seq_len=3 seq_len_list= alpha=2 alpha_list= a=0 a_list= checkpoint= use_local_max=0
[run.sh] Mode: fine+recursive+coarse
epoch 1 loss 0.001669 time 39.16s
epoch 2 loss 0.000894 time 29.45s
epoch 3 loss 0.000768 time 29.60s
epoch 4 loss 0.000693 time 29.47s
epoch 5 loss 0.000642 time 29.55s
epoch 6 loss 0.000600 time 29.93s
epoch 7 loss 0.000566 time 29.62s
epoch 8 loss 0.000539 time 29.51s
epoch 9 loss 0.000518 time 29.47s
epoch 10 loss 0.000501 time 29.46s
epoch 11 loss 0.000487 time 29.48s
epoch 12 loss 0.000475 time 29.48s
epoch 13 loss 0.000464 time 29.50s
epoch 14 loss 0.000454 time 29.66s
epoch 15 loss 0.000445 time 30.10s
epoch 16 loss 0.000438 time 29.77s
epoch 17 loss 0.000431 time 29.75s
epoch 18 loss 0.000425 time 30.03s
epoch 19 loss 0.000420 time 29.83s
epoch 20 loss 0.000415 time 29.71s
[run.sh] Coarse trainval segment H5: ./output/segments_trainval.h5
[run.sh] Coarse trainval boundaries: ./output/boundaries_trainval_fine.json
/dev/ssd1/gjw/prvr/semantic-transformer-v2/boundary_detection/inference_boundary.py:375: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  ckpt = torch.load(args.checkpoint, map_location=device)
epoch 1 loss 0.090599 time 10.22s
epoch 2 loss 0.066905 time 10.34s
epoch 3 loss 0.064478 time 10.13s
epoch 4 loss 0.062977 time 10.12s
epoch 5 loss 0.061302 time 10.24s
epoch 6 loss 0.060132 time 10.27s
epoch 7 loss 0.058725 time 10.12s
epoch 8 loss 0.058345 time 10.12s
epoch 9 loss 0.057314 time 10.12s
epoch 10 loss 0.056167 time 10.21s
epoch 11 loss 0.055974 time 10.11s
epoch 12 loss 0.055164 time 10.57s
epoch 13 loss 0.055173 time 10.39s
epoch 14 loss 0.054417 time 10.13s
epoch 15 loss 0.053939 time 10.11s
epoch 16 loss 0.053273 time 10.15s
epoch 17 loss 0.053402 time 10.20s
epoch 18 loss 0.052908 time 10.10s
epoch 19 loss 0.052364 time 10.13s
epoch 20 loss 0.052309 time 10.41s
/dev/ssd1/gjw/prvr/semantic-transformer-v2/boundary_detection/inference_boundary.py:375: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  ckpt = torch.load(args.checkpoint, map_location=device)
/dev/ssd1/gjw/prvr/semantic-transformer-v2/boundary_detection/inference_boundary.py:389: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  coarse_ckpt = torch.load(args.coarse_checkpoint, map_location=device)
/dev/ssd1/gjw/prvr/semantic-transformer-v2/boundary_detection/inference_boundary.py:375: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  ckpt = torch.load(args.checkpoint, map_location=device)
/dev/ssd1/gjw/prvr/semantic-transformer-v2/boundary_detection/inference_boundary.py:389: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  coarse_ckpt = torch.load(args.coarse_checkpoint, map_location=device)
/dev/ssd1/gjw/prvr/semantic-transformer-v2/boundary_detection/inference_boundary.py:401: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  recursive_ckpt = torch.load(args.recursive_checkpoint, map_location=device)
